<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Minecraft Clone</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
        }
        #debugInfo {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }
        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            z-index: 100;
        }
        #craftingMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            display: none;
            grid-template-columns: repeat(3, 50px);
            gap: 4px;
            z-index: 1500;
        }
        .craftingSlot {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .craftingResult {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #888;
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .inventorySlot {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
        }
        .inventorySlot:hover {
            border-color: #fff;
        }
        .inventorySlot.selected {
            border-color: #fff;
        }
        .blockPreview {
            width: 30px;
            height: 30px;
            position: relative;
        }
        .blockCount {
            position: absolute;
            bottom: -15px;
            right: -15px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 1px black;
        }
    </style>
</head>
<body>
    <div id="debugInfo">Caricamento...</div>
    <div id="crosshair"></div>
    <div id="hotbar"></div>
    <div id="craftingMenu"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    class MinecraftGame {
        debug(message) {
            if (this.debugElement) {
                this.debugElement.innerHTML += "<br>" + message;
                console.log(message);
            }
        }

        constructor() {
            this.debugElement = document.getElementById('debugInfo');
            this.debug("Inizializzazione...");

            // Costanti di gioco
            this.PLAYER_HEIGHT = 1.8;
            this.PLAYER_WIDTH = 0.6;
            this.GRAVITY = 0.01;
            this.JUMP_FORCE = 0.2;
            this.COLLISION_SEGMENTS = 8; // Per una migliore rilevazione delle collisioni

            // Variabili di gioco
            this.playerVelocity = new THREE.Vector3();
            this.playerOnGround = false;
            this.canJump = false;

            // Crafting recipes
            this.craftingRecipes = [
                {
                    input: [
                        ['wood', 'wood', 'wood'],
                        ['wood', null, 'wood'],
                        ['wood', 'wood', 'wood']
                    ],
                    output: { type: 'chest', count: 1 }
                },
                {
                    input: [
                        ['wood', 'wood', null],
                        ['wood', 'wood', null],
                        [null, null, null]
                    ],
                    output: { type: 'workbench', count: 1 }
                },
                {
                    input: [
                        ['stone', 'stone', 'stone'],
                        [null, 'wood', null],
                        [null, 'wood', null]
                    ],
                    output: { type: 'pickaxe', count: 1 }
                }
            ];

            try {
                this.initializeGame();
            } catch (error) {
                this.debug("ERRORE: " + error.message);
                console.error(error);
            }
        }

                initializeGame() {
            // Scene setup
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x87CEEB);

            // Camera setup
            this.camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            this.camera.position.set(0, this.PLAYER_HEIGHT, 10);
            this.camera.lookAt(0, this.PLAYER_HEIGHT, 0);

            // Renderer setup
            this.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.shadowMap.enabled = true;
            document.body.appendChild(this.renderer.domElement);

            // Materiali migliorati
            this.blockMaterials = {
                grass: new THREE.MeshStandardMaterial({ 
                    color: 0x55AA55,
                    roughness: 0.8,
                    metalness: 0.2
                }),
                dirt: new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.9,
                    metalness: 0.1
                }),
                stone: new THREE.MeshStandardMaterial({ 
                    color: 0x808080,
                    roughness: 0.7,
                    metalness: 0.3
                }),
                wood: new THREE.MeshStandardMaterial({ 
                    color: 0x8B5A2B,
                    roughness: 0.8,
                    metalness: 0.1
                }),
                leaves: new THREE.MeshStandardMaterial({ 
                    color: 0x2D5A27,
                    roughness: 0.8,
                    metalness: 0.1,
                    transparent: true,
                    opacity: 0.9
                }),
                workbench: new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.8,
                    metalness: 0.2
                }),
                chest: new THREE.MeshStandardMaterial({ 
                    color: 0xA0522D,
                    roughness: 0.7,
                    metalness: 0.3
                }),
                glass: new THREE.MeshStandardMaterial({ 
                    color: 0xAAAAAA,
                    roughness: 0.2,
                    metalness: 0.8,
                    transparent: true,
                    opacity: 0.5
                })
            };

            // Inventory setup
            this.inventory = {
                hotbar: Array(9).fill().map(() => ({ type: null, count: 0 })),
                items: Array(27).fill().map(() => ({ type: null, count: 0 })),
                selectedSlot: 0,
                craftingGrid: Array(9).fill().map(() => ({ type: null, count: 0 }))
            };

            // Add initial items
            this.inventory.hotbar[0] = { type: 'grass', count: 64 };
            this.inventory.hotbar[1] = { type: 'dirt', count: 64 };
            this.inventory.hotbar[2] = { type: 'stone', count: 64 };
            this.inventory.hotbar[3] = { type: 'wood', count: 64 };
            this.inventory.hotbar[4] = { type: 'leaves', count: 64 };
            this.inventory.hotbar[5] = { type: 'glass', count: 64 };

            // Setup del gioco
            this.setupLights();
            this.blocks = [];
            this.generateWorld();
            this.setupControls();
            this.setupInventoryUI();
            this.setupCraftingUI();

            // Eventi resize
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });

            this.debug("Inizializzazione completata");
        }

        setupLights() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(100, 100, 100);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            this.scene.add(sun);
        }

        generateWorld() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);

            // Genera terreno pi√π grande e vario
            for (let x = -10; x <= 10; x++) {
                for (let z = -10; z <= 10; z++) {
                    const height = Math.floor(
                        (Math.sin(x * 0.3) * 2 + Math.cos(z * 0.3) * 2) + 
                        (Math.random() * 0.5)
                    ) + 4;

                    for (let y = 0; y < height; y++) {
                        let material;
                        if (y === height - 1) {
                            material = this.blockMaterials.grass;
                        } else if (y > height - 3) {
                            material = this.blockMaterials.dirt;
                        } else {
                            material = this.blockMaterials.stone;
                        }

                        this.createBlock(x, y, z, material);
                    }

                    // Genera alberi casualmente
                    if (Math.random() < 0.05 && height > 3) {
                        this.generateTree(x, height, z);
                    }
                }
            }
        }

        generateTree(x, y, z) {
            const trunkHeight = 4 + Math.floor(Math.random() * 2);
            
            // Tronco
            for (let i = 0; i < trunkHeight; i++) {
                this.createBlock(x, y + i, z, this.blockMaterials.wood);
            }

            // Foglie
            for (let dx = -2; dx <= 2; dx++) {
                for (let dz = -2; dz <= 2; dz++) {
                    for (let dy = 0; dy <= 2; dy++) {
                        if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 3) {
                            this.createBlock(
                                x + dx,
                                y + trunkHeight + dy - 1,
                                z + dz,
                                this.blockMaterials.leaves
                            );
                        }
                    }
                }
            }
        }

                checkCollision(position) {
            // Crea una box di collisione per il giocatore
            const playerBox = new THREE.Box3();
            const halfWidth = this.PLAYER_WIDTH / 2;
            const playerMin = new THREE.Vector3(
                position.x - halfWidth,
                position.y,
                position.z - halfWidth
            );
            const playerMax = new THREE.Vector3(
                position.x + halfWidth,
                position.y + this.PLAYER_HEIGHT,
                position.z + halfWidth
            );
            playerBox.set(playerMin, playerMax);

            // Controlla solo i blocchi vicini per ottimizzazione
            for (const block of this.blocks) {
                if (block.position.distanceTo(position) < 3) {
                    const blockBox = new THREE.Box3().setFromObject(block);
                    if (playerBox.intersectsBox(blockBox)) {
                        return true;
                    }
                }
            }
            return false;
        }

        setupCraftingUI() {
            const craftingMenu = document.getElementById('craftingMenu');
            craftingMenu.innerHTML = '';

            // Crea la griglia di crafting 3x3
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'craftingSlot';
                slot.setAttribute('data-index', i);
                slot.addEventListener('click', () => this.handleCraftingSlotClick(i));
                craftingMenu.appendChild(slot);
            }

            // Aggiungi lo slot del risultato
            const resultSlot = document.createElement('div');
            resultSlot.className = 'craftingResult';
            resultSlot.addEventListener('click', () => this.craftItem());
            craftingMenu.appendChild(resultSlot);

            // Aggiorna l'UI del crafting
            this.updateCraftingUI();
        }

        handleCraftingSlotClick(index) {
            const selectedItem = this.inventory.hotbar[this.inventory.selectedSlot];
            const craftingSlot = this.inventory.craftingGrid[index];

            if (selectedItem.count > 0) {
                // Sposta l'oggetto dall'hotbar al crafting
                if (craftingSlot.type === null) {
                    craftingSlot.type = selectedItem.type;
                    craftingSlot.count = 1;
                    selectedItem.count--;
                }
            } else if (craftingSlot.type !== null) {
                // Sposta l'oggetto dal crafting all'hotbar
                if (selectedItem.type === null) {
                    selectedItem.type = craftingSlot.type;
                    selectedItem.count = craftingSlot.count;
                    craftingSlot.type = null;
                    craftingSlot.count = 0;
                }
            }

            this.updateCraftingUI();
            this.updateHotbarUI();
            this.checkCraftingResult();
        }

        checkCraftingResult() {
            // Converti la griglia di crafting in un formato confrontabile
            const currentRecipe = [];
            for (let i = 0; i < 9; i += 3) {
                const row = [];
                for (let j = 0; j < 3; j++) {
                    const slot = this.inventory.craftingGrid[i + j];
                    row.push(slot.type);
                }
                currentRecipe.push(row);
            }

            // Cerca una ricetta corrispondente
            for (const recipe of this.craftingRecipes) {
                if (this.compareRecipes(currentRecipe, recipe.input)) {
                    const resultSlot = document.querySelector('.craftingResult');
                    resultSlot.innerHTML = `
                        <div class="blockPreview" style="background-color: ${this.getBlockColor(recipe.output.type)}">
                            <span class="blockCount">${recipe.output.count}</span>
                        </div>
                    `;
                    resultSlot.setAttribute('data-recipe', JSON.stringify(recipe.output));
                    return;
                }
            }

            // Nessuna ricetta trovata
            document.querySelector('.craftingResult').innerHTML = '';
            document.querySelector('.craftingResult').removeAttribute('data-recipe');
        }

        compareRecipes(current, recipe) {
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (recipe[i][j] !== current[i][j]) {
                        return false;
                    }
                }
            }
            return true;
        }

        craftItem() {
            const resultSlot = document.querySelector('.craftingResult');
            const recipeOutput = resultSlot.getAttribute('data-recipe');
            
            if (recipeOutput) {
                const output = JSON.parse(recipeOutput);
                
                // Aggiungi l'oggetto craftato all'inventario
                this.addToInventory(output.type, output.count);

                // Pulisci la griglia di crafting
                for (let i = 0; i < 9; i++) {
                    this.inventory.craftingGrid[i] = { type: null, count: 0 };
                }

                this.updateCraftingUI();
                this.checkCraftingResult();
            }
        }

        addToInventory(type, count) {
            // Cerca uno slot esistente non pieno
            for (let slot of [...this.inventory.hotbar, ...this.inventory.items]) {
                if (slot.type === type && slot.count < 64) {
                    const spaceAvailable = 64 - slot.count;
                    const amountToAdd = Math.min(count, spaceAvailable);
                    slot.count += amountToAdd;
                    count -= amountToAdd;
                    if (count <= 0) return;
                }
            }

            // Se rimangono oggetti, cerca slot vuoti
            if (count > 0) {
                for (let slot of [...this.inventory.hotbar, ...this.inventory.items]) {
                    if (slot.type === null) {
                        slot.type = type;
                        slot.count = Math.min(count, 64);
                        count -= slot.count;
                        if (count <= 0) return;
                    }
                }
            }

            this.updateHotbarUI();
        }

                updateMovement() {
            if (!document.pointerLockElement) return;

            const moveSpeed = 0.15;
            const direction = new THREE.Vector3();

            // Calcola la direzione del movimento basata sull'input
            if (this.keys['w']) direction.z -= 1;
            if (this.keys['s']) direction.z += 1;
            if (this.keys['a']) direction.x -= 1;
            if (this.keys['d']) direction.x += 1;

            direction.normalize();
            direction.applyQuaternion(this.camera.quaternion);
            direction.y = 0; // Mantieni il movimento orizzontale

            // Applica la gravit√†
            this.playerVelocity.y -= this.GRAVITY;

            // Gestione del salto
            if (this.keys[' '] && this.canJump) {
                this.playerVelocity.y = this.JUMP_FORCE;
                this.canJump = false;
            }

            // Calcola la nuova posizione
            const newPosition = this.camera.position.clone();
            
            // Movimento orizzontale
            const horizontalVelocity = direction.multiplyScalar(moveSpeed);
            newPosition.add(horizontalVelocity);

            // Check collisione orizzontale
            if (!this.checkCollision(newPosition)) {
                this.camera.position.copy(newPosition);
            }

            // Movimento verticale
            const verticalPosition = this.camera.position.clone();
            verticalPosition.y += this.playerVelocity.y;

            // Check collisione verticale
            if (!this.checkCollision(verticalPosition)) {
                this.camera.position.y = verticalPosition.y;
                this.canJump = false;
            } else {
                if (this.playerVelocity.y < 0) {
                    this.canJump = true;
                }
                this.playerVelocity.y = 0;
            }

            // Aggiorna il debug info
            this.updateDebugInfo();
        }

        updateDebugInfo() {
            const pos = this.camera.position;
            this.debugElement.innerHTML = `
                Posizione: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})<br>
                Velocit√† Y: ${this.playerVelocity.y.toFixed(2)}<br>
                Pu√≤ saltare: ${this.canJump}<br>
                FPS: ${Math.round(1000 / (performance.now() - this._lastFrameTime || 0))}
            `;
            this._lastFrameTime = performance.now();
        }

        setupControls() {
            this.keys = {};
            
            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                this.keys[e.key.toLowerCase()] = true;
                
                // Gestione tasti speciali
                if (e.key === 'e') {
                    this.toggleCrafting();
                }
                if (e.key >= '1' && e.key <= '9') {
                    const index = parseInt(e.key) - 1;
                    if (index < this.inventory.hotbar.length) {
                        this.selectInventorySlot(index);
                    }
                }
            });

            window.addEventListener('keyup', (e) => {
                this.keys[e.key.toLowerCase()] = false;
            });

            // Mouse controls
            this.renderer.domElement.addEventListener('click', () => {
                if (!document.pointerLockElement) {
                    this.renderer.domElement.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === this.renderer.domElement) {
                    document.getElementById('craftingMenu').style.display = 'none';
                }
            });

            // Mouse movement
            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === this.renderer.domElement) {
                    this.camera.rotation.y -= e.movementX * 0.002;
                    this.camera.rotation.x -= e.movementY * 0.002;
                    this.camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotation.x));
                }
            });

            // Mouse buttons
            this.renderer.domElement.addEventListener('mousedown', (e) => {
                if (document.pointerLockElement === this.renderer.domElement) {
                    if (e.button === 0) { // Left click
                        this.handleBlockBreak();
                    } else if (e.button === 2) { // Right click
                        this.handleBlockPlace();
                    }
                }
            });

            // Prevent context menu
            this.renderer.domElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Mouse wheel for hotbar selection
            window.addEventListener('wheel', (e) => {
                if (document.pointerLockElement === this.renderer.domElement) {
                    const delta = Math.sign(e.deltaY);
                    this.inventory.selectedSlot = 
                        (this.inventory.selectedSlot + delta + this.inventory.hotbar.length) % 
                        this.inventory.hotbar.length;
                    this.updateHotbarUI();
                }
            });
        }

        toggleCrafting() {
            const craftingMenu = document.getElementById('craftingMenu');
            if (craftingMenu.style.display === 'none' || craftingMenu.style.display === '') {
                craftingMenu.style.display = 'grid';
                document.exitPointerLock();
            } else {
                craftingMenu.style.display = 'none';
                this.renderer.domElement.requestPointerLock();
            }
        }

        animate() {
            requestAnimationFrame(() => this.animate());

            try {
                this.updateMovement();
                this.renderer.render(this.scene, this.camera);
            } catch (error) {
                console.error("Errore di rendering:", error);
                this.debug("ERRORE ANIMAZIONE: " + error.message);
            }
        }

        start() {
            this.debug("Avvio gioco");
            this.animate();
        }
    }

    // Avvio del gioco
    window.onload = () => {
        try {
            const game = new MinecraftGame();
            game.start();
        } catch (error) {
            console.error("Errore fatale:", error);
            document.getElementById('debugInfo').innerHTML += "<br>ERRORE FATALE: " + error.message;
        }
    };
    </script>
</body>
</html>
