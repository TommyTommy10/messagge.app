<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Minecraft Clone</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #debugInfo {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }
        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="debugInfo">Caricamento...</div>
    <div id="crosshair"></div>
    <div id="hotbar"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    class MinecraftGame {
        debug(message) {
            if (this.debugElement) {
                this.debugElement.innerHTML += "<br>" + message;
                console.log(message);
            }
        }

        constructor() {
            this.debugElement = document.getElementById('debugInfo');
            this.debug("Inizializzazione...");

            try {
                // Inizializzazione base
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.debug("Scena creata");

                this.inventory = {
                    slots: [
                        { type: 'grass', count: 64 },
                        { type: 'dirt', count: 64 },
                        { type: 'stone', count: 64 }
                    ],
                    selectedSlot: 0
                };

                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 5, 10);
                this.camera.lookAt(0, 0, 0);
                this.debug("Camera configurata");

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.body.appendChild(this.renderer.domElement);
                this.debug("Renderer creato");

                // Setup di base
                this.setupLights();
                this.blocks = [];
                this.generateWorld();
                this.setupControls();
                this.setupInventoryUI();
                
                // Eventi resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                this.debug("Inizializzazione completata");
            } catch (error) {
                this.debug("ERRORE: " + error.message);
                console.error(error);
            }
        }

        setupLights() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(100, 100, 100);
            sun.castShadow = true;
            this.scene.add(sun);
            this.debug("Luci configurate");
        }

        generateWorld() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);

            const materials = {
                grass: new THREE.MeshStandardMaterial({ color: 0x55AA55 }),
                dirt: new THREE.MeshStandardMaterial({ color: 0x8B4513 }),
                stone: new THREE.MeshStandardMaterial({ color: 0x808080 })
            };

            for (let x = -5; x <= 5; x++) {
                for (let z = -5; z <= 5; z++) {
                    const height = Math.floor(Math.sin(x * 0.3) * 2 + Math.cos(z * 0.3) * 2) + 3;

                    for (let y = 0; y < height; y++) {
                        let material;
                        if (y === height - 1) {
                            material = materials.grass;
                        } else if (y > height - 3) {
                            material = materials.dirt;
                        } else {
                            material = materials.stone;
                        }

                        const block = new THREE.Mesh(geometry, material);
                        block.position.set(x, y, z);
                        block.castShadow = true;
                        block.receiveShadow = true;
                        this.scene.add(block);
                        this.blocks.push(block);
                    }
                }
            }
            this.debug("Mondo generato");
        }

        setupControls() {
            this.keys = {};
            this.moveSpeed = 0.1;
            this.rotationSpeed = 0.003; // Aumentato per una rotazione piÃ¹ veloce

            // Controlli tastiera
            window.addEventListener('keydown', (e) => {
                this.keys[e.key.toLowerCase()] = true;
                if (e.key >= '1' && e.key <= '9') {
                    const index = parseInt(e.key) - 1;
                    if (index < this.inventory.slots.length) {
                        this.selectInventorySlot(index);
                    }
                }
            });

            window.addEventListener('keyup', (e) => {
                this.keys[e.key.toLowerCase()] = false;
            });

            // Controllo mouse
            this.renderer.domElement.addEventListener('click', () => {
                this.renderer.domElement.requestPointerLock();
            });

            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === this.renderer.domElement) {
                    this.camera.rotation.y -= e.movementX * this.rotationSpeed;
                    this.camera.rotation.x -= e.movementY * this.rotationSpeed;
                    this.camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotation.x));
                }
            });

            // Gestione blocchi
            this.renderer.domElement.addEventListener('mousedown', (e) => {
                if (document.pointerLockElement === this.renderer.domElement) {
                    if (e.button === 0) {
                        this.handleBlockBreak();
                    } else if (e.button === 2) {
                        this.handleBlockPlace();
                    }
                }
            });

            // Previeni menu contestuale
            this.renderer.domElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            this.debug("Controlli configurati");
        }

        setupInventoryUI() {
            const hotbar = document.getElementById('hotbar');
            hotbar.innerHTML = '';

            for (let i = 0; i < this.inventory.slots.length; i++) {
                const slot = document.createElement('div');
                slot.style.cssText = `
                    width: 50px;
                    height: 50px;
                    border: 2px solid ${i === this.inventory.selectedSlot ? '#fff' : '#666'};
                    background: rgba(0, 0, 0, 0.3);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-family: monospace;
                    cursor: pointer;
                    user-select: none;
                `;
                this.updateSlotUI(slot, this.inventory.slots[i]);
                slot.addEventListener('click', () => this.selectInventorySlot(i));
                hotbar.appendChild(slot);
            }
            this.debug("Inventario configurato");
        }

        updateSlotUI(slotElement, slotData) {
            const colors = {
                'grass': '#55AA55',
                'dirt': '#8B4513',
                'stone': '#808080'
            };
            
            slotElement.innerHTML = `
                <div style="
                    width: 30px;
                    height: 30px;
                    background: ${colors[slotData.type]};
                    position: relative;
                ">
                    <span style="
                        position: absolute;
                        bottom: -20px;
                        right: -20px;
                        color: white;
                        font-size: 12px;
                    ">${slotData.count}</span>
                </div>
            `;
        }

        selectInventorySlot(index) {
            const hotbar = document.getElementById('hotbar');
            hotbar.children[this.inventory.selectedSlot].style.border = '2px solid #666';
            hotbar.children[index].style.border = '2px solid #fff';
            this.inventory.selectedSlot = index;
        }

        handleBlockBreak() {
            const raycaster = new THREE.Raycaster();
            const center = new THREE.Vector2(0, 0);
            
            raycaster.setFromCamera(center, this.camera);
            const intersects = raycaster.intersectObjects(this.blocks);

            if (intersects.length > 0) {
                const block = intersects[0].object;
                
                // Determina il tipo di blocco
                const blockType = block.material.color.getHexString() === '55aa55' ? 'grass' :
                                block.material.color.getHexString() === '8b4513' ? 'dirt' : 'stone';

                // Aggiungi il blocco all'inventario
                const slot = this.inventory.slots.find(s => s.type === blockType && s.count < 64);
                if (slot) {
                    slot.count++;
                    this.updateSlotUI(
                        document.getElementById('hotbar').children[this.inventory.slots.indexOf(slot)],
                        slot
                    );
                }

                // Rimuovi il blocco dal mondo
                this.scene.remove(block);
                this.blocks = this.blocks.filter(b => b !== block);
            }
        }

        handleBlockPlace() {
            const raycaster = new THREE.Raycaster();
            const center = new THREE.Vector2(0, 0);
            
            raycaster.setFromCamera(center, this.camera);
            const intersects = raycaster.intersectObjects(this.blocks);

            if (intersects.length > 0) {
                const intersection = intersects[0];
                const normal = intersection.face.normal;
                const position = intersection.point.add(normal.multiplyScalar(0.5));

                position.x = Math.round(position.x);
                position.y = Math.round(position.y);
                position.z = Math.round(position.z);

                const blockExists = this.blocks.some(block => 
                    block.position.x === position.x &&
                    block.position.y === position.y &&
                    block.position.z === position.z
                );

                if (!blockExists) {
                    const selectedSlot = this.inventory.slots[this.inventory.selectedSlot];
                    if (selectedSlot.count > 0) {
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        const material = new THREE.MeshStandardMaterial({ 
                            color: {
                                'grass': 0x55AA55,
                                'dirt': 0x8B4513,
                                'stone': 0x808080
                            }[selectedSlot.type]
                        });

                        const block = new THREE.Mesh(geometry, material);
                        block.position.copy(position);
                        block.castShadow = true;
                        block.receiveShadow = true;
                        this.scene.add(block);
                        this.blocks.push(block);

                        selectedSlot.count--;
                        this.updateSlotUI(
                            document.getElementById('hotbar').children[this.inventory.selectedSlot],
                            selectedSlot
                        );
                    }
                }
            }
        }

        updateMovement() {
            if (!this.keys) return;

            const moveSpeed = this.moveSpeed;
            const direction = new THREE.Vector3();

            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(this.camera.quaternion);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(this.camera.quaternion);
            right.y = 0;
            right.normalize();

            if (this.keys['w']) direction.add(forward);
            if (this.keys['s']) direction.sub(forward);
            if (this.keys['a']) direction.sub(right);
            if (this.keys['d']) direction.add(right);
            
            if (this.keys[' ']) this.camera.position.y += moveSpeed;
            if (this.keys['shift']) this.camera.position.y -= moveSpeed;

            if (direction.length() > 0) {
                direction.normalize();
                this.camera.position.addScaledVector(direction, moveSpeed);
            }
        }

        animate() {
            requestAnimationFrame(() => this.animate());
            try {
                this.updateMovement();
                this.renderer.render(this.scene, this.camera);
            } catch (error) {
                this.debug("ERRORE ANIMAZIONE: " + error.message);
            }
        }

        start() {
            this.debug("Avvio gioco");
            this.animate();
        }
    }

    window.onload = () => {
        try {
            const game = new MinecraftGame();
            game.start();
        } catch (error) {
            console.error("Errore fatale:", error);
            document.getElementById('debugInfo').innerHTML += "<br>ERRORE FATALE: " + error.message;
        }
    };
    </script>
</body>
</html>
