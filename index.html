<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Minecraft Clone</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #debugInfo {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="debugInfo">Caricamento...</div>
    <div id="crosshair"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    class MinecraftGame {
        constructor() {
            this.debugElement = document.getElementById('debugInfo');
            this.debug("Inizializzazione...");

            try {
                // Inizializzazione base
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); // Cielo azzurro
                this.debug("Scena creata");

                this.inventory = {
            slots: [
                { type: 'grass', count: 64 },
                { type: 'dirt', count: 64 },
                { type: 'stone', count: 64 }
            ],
            selectedSlot: 0
        };

                // Camera con posizione iniziale migliore
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 5, 10);
                this.camera.lookAt(0, 0, 0);
                this.debug("Camera configurata");

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.body.appendChild(this.renderer.domElement);
                this.debug("Renderer creato");

                // Luci
                this.setupLights();
                this.debug("Luci configurate");

                // Mondo
                this.blocks = [];
                this.generateWorld();
                this.debug("Mondo generato");

                // Controlli
                this.setupControls();
                this.debug("Controlli configurati");

                 // Aggiungi questa chiamata dopo setupControls()
        this.setupInventoryUI();
        this.debug("Inventario configurato");
    }

                // Eventi resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                this.debug("Inizializzazione completata");
            } catch (error) {
                this.debug("ERRORE: " + error.message);
                console.error(error);
            }
        }

        setupLights() {
            // Luce ambientale
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(ambient);

            // Luce direzionale (sole)
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(100, 100, 100);
            sun.castShadow = true;
            this.scene.add(sun);
        }

        generateWorld() {
            // Geometria blocco
            const geometry = new THREE.BoxGeometry(1, 1, 1);

            // Materiali
            const materials = {
                grass: new THREE.MeshStandardMaterial({ color: 0x55AA55 }),
                dirt: new THREE.MeshStandardMaterial({ color: 0x8B4513 }),
                stone: new THREE.MeshStandardMaterial({ color: 0x808080 })
            };

            // Genera terreno base (pi√π piccolo per test)
            for (let x = -5; x <= 5; x++) {
                for (let z = -5; z <= 5; z++) {
                    // Altezza semplice
                    const height = Math.floor(Math.sin(x * 0.3) * 2 + Math.cos(z * 0.3) * 2) + 3;

                    for (let y = 0; y < height; y++) {
                        let material;
                        if (y === height - 1) {
                            material = materials.grass;
                        } else if (y > height - 3) {
                            material = materials.dirt;
                        } else {
                            material = materials.stone;
                        }

                        const block = new THREE.Mesh(geometry, material);
                        block.position.set(x, y, z);
                        block.castShadow = true;
                        block.receiveShadow = true;
                        this.scene.add(block);
                        this.blocks.push(block);
                    }
                }
            }
        }

        setupControls() {
            this.keys = {};
            this.moveSpeed = 0.1;
            this.rotationSpeed = 0.002;

            // Controlli tastiera
            window.addEventListener('keydown', (e) => {
                this.keys[e.key.toLowerCase()] = true;
            });

            window.addEventListener('keyup', (e) => {
                this.keys[e.key.toLowerCase()] = false;
            });

            // Controllo mouse
            this.renderer.domElement.addEventListener('click', () => {
                this.renderer.domElement.requestPointerLock();
            });

            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === this.renderer.domElement) {
                    this.camera.rotation.y -= e.movementX * this.rotationSpeed;
                    this.camera.rotation.x -= e.movementY * this.rotationSpeed;
                    this.camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotation.x));
                }
            });

            // Click per rompere blocchi
            this.renderer.domElement.addEventListener('mousedown', (e) => {
                if (document.pointerLockElement === this.renderer.domElement) {
                    this.handleBlockBreak();
                }
            });
        }

        handleBlockBreak() {
            const raycaster = new THREE.Raycaster();
            const center = new THREE.Vector2(0, 0);
            
            raycaster.setFromCamera(center, this.camera);
            const intersects = raycaster.intersectObjects(this.blocks);

            if (intersects.length > 0) {
                const block = intersects[0].object;
                this.scene.remove(block);
                this.blocks = this.blocks.filter(b => b !== block);
            }
        }

        updateMovement() {
            if (!this.keys) return;

            const moveSpeed = this.moveSpeed;
            const direction = new THREE.Vector3();

            // Direzione frontale della camera
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(this.camera.quaternion);
            forward.y = 0;
            forward.normalize();

            // Direzione laterale della camera
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(this.camera.quaternion);
            right.y = 0;
            right.normalize();

            if (this.keys['w']) direction.add(forward);
            if (this.keys['s']) direction.sub(forward);
            if (this.keys['a']) direction.sub(right);
            if (this.keys['d']) direction.add(right);
            
            if (this.keys[' ']) this.camera.position.y += moveSpeed; // Salta
            if (this.keys['shift']) this.camera.position.y -= moveSpeed; // Scendi

            if (direction.length() > 0) {
                direction.normalize();
                this.camera.position.addScaledVector(direction, moveSpeed);
            }
        }

        debug(message) {
            if (this.debugElement) {
                this.debugElement.innerHTML += "<br>" + message;
                console.log(message);
            }
        }

        animate() {
            requestAnimationFrame(() => this.animate());

            try {
                this.updateMovement();
                this.renderer.render(this.scene, this.camera);
            } catch (error) {
                this.debug("ERRORE ANIMAZIONE: " + error.message);
            }
        }

        start() {
            this.debug("Avvio gioco");
            this.animate();
        }
    }

    // Avvio con gestione errori
    window.onload = () => {
        try {
            const game = new MinecraftGame();
            game.start();
        } catch (error) {
            console.error("Errore fatale:", error);
            document.getElementById('debugInfo').innerHTML += "<br>ERRORE FATALE: " + error.message;
        }
    };

        // Aggiungi questo nuovo metodo
    setupInventoryUI() {
        const inventoryBar = document.createElement('div');
        inventoryBar.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
        `;

         // Crea gli slot dell'inventario
        for (let i = 0; i < this.inventory.slots.length; i++) {
            const slot = document.createElement('div');
            slot.style.cssText = `
                width: 50px;
                height: 50px;
                border: 2px solid ${i === this.inventory.selectedSlot ? '#fff' : '#666'};
                background: rgba(0, 0, 0, 0.3);
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-family: monospace;
                cursor: pointer;
                user-select: none;
            `;
            slot.setAttribute('data-slot', i);
            this.updateSlotUI(slot, this.inventory.slots[i]);
            
            slot.addEventListener('click', () => this.selectInventorySlot(i));
            inventoryBar.appendChild(slot);
        }

        document.body.appendChild(inventoryBar);
        this.inventoryBar = inventoryBar;
    }

    // Aggiungi questo nuovo metodo
    updateSlotUI(slotElement, slotData) {
        const colors = {
            'grass': '#55AA55',
            'dirt': '#8B4513',
            'stone': '#808080'
        };
        
        slotElement.innerHTML = `
            <div style="
                width: 30px;
                height: 30px;
                background: ${colors[slotData.type]};
                position: relative;
            ">
                <span style="
                    position: absolute;
                    bottom: -20px;
                    right: -20px;
                    color: white;
                    font-size: 12px;
                ">${slotData.count}</span>
            </div>
        `;
    }

    // Aggiungi questo nuovo metodo
    selectInventorySlot(index) {
        const slots = this.inventoryBar.children;
        slots[this.inventory.selectedSlot].style.border = '2px solid #666';
        slots[index].style.border = '2px solid #fff';
        this.inventory.selectedSlot = index;
    }

    // Modifica setupControls() aggiungendo questi listener
    setupControls() {
        // ... codice esistente ...

        // Selezione slot con tasti numerici
        window.addEventListener('keydown', (e) => {
            if (e.key >= '1' && e.key <= '9') {
                const index = parseInt(e.key) - 1;
                if (index < this.inventory.slots.length) {
                    this.selectInventorySlot(index);
                }
            }
        });

        // Click destro per piazzare blocchi
        this.renderer.domElement.addEventListener('mousedown', (e) => {
            if (document.pointerLockElement === this.renderer.domElement) {
                if (e.button === 0) { // Click sinistro
                    this.handleBlockBreak();
                } else if (e.button === 2) { // Click destro
                    this.handleBlockPlace();
                }
            }
        });

        // Previeni il menu contestuale del click destro
        this.renderer.domElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
    }

    // Aggiungi questo nuovo metodo
    handleBlockPlace() {
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0, 0);
        
        raycaster.setFromCamera(center, this.camera);
        const intersects = raycaster.intersectObjects(this.blocks);

        if (intersects.length > 0) {
            const intersection = intersects[0];
            const normal = intersection.face.normal;
            const position = intersection.point.add(normal);

            // Arrotonda alla posizione della griglia
            position.x = Math.round(position.x);
            position.y = Math.round(position.y);
            position.z = Math.round(position.z);

            // Controlla se c'√® gi√† un blocco in questa posizione
            const blockExists = this.blocks.some(block => 
                block.position.x === position.x &&
                block.position.y === position.y &&
                block.position.z === position.z
            );

            if (!blockExists) {
                const selectedSlot = this.inventory.slots[this.inventory.selectedSlot];
                if (selectedSlot.count > 0) {
                    // Crea il nuovo blocco
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: {
                            'grass': 0x55AA55,
                            'dirt': 0x8B4513,
                            'stone': 0x808080
                        }[selectedSlot.type]
                    });

                    const block = new THREE.Mesh(geometry, material);
                    block.position.copy(position);
                    block.castShadow = true;
                    block.receiveShadow = true;
                    this.scene.add(block);
                    this.blocks.push(block);

                    // Aggiorna l'inventario
                    selectedSlot.count--;
                    this.updateSlotUI(
                        this.inventoryBar.children[this.inventory.selectedSlot], 
                        selectedSlot
                    );
                }
            }
        }
    }

    // Modifica handleBlockBreak() per aggiungere i blocchi all'inventario
    handleBlockBreak() {
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0, 0);
        
        raycaster.setFromCamera(center, this.camera);
        const intersects = raycaster.intersectObjects(this.blocks);

        if (intersects.length > 0) {
            const block = intersects[0].object;
            
            // Determina il tipo di blocco
            const blockType = block.material.color.getHexString() === '55aa55' ? 'grass' :
                            block.material.color.getHexString() === '8b4513' ? 'dirt' : 'stone';

            // Aggiungi il blocco all'inventario
            const slot = this.inventory.slots.find(s => s.type === blockType && s.count < 64);
            if (slot) {
                slot.count++;
                this.updateSlotUI(
                    this.inventoryBar.children[this.inventory.slots.indexOf(slot)], 
                    slot
                );
            }

            // Rimuovi il blocco dal mondo
            this.scene.remove(block);
            this.blocks = this.blocks.filter(b => b !== block);
        }
    }
}
    </script>
</body>
</html>
